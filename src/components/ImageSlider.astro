---
export interface Props {
  images: {
    src: string;
    alt: string;
  }[];
  autoplay?: boolean;
  autoplayDelay?: number;
}

const { images, autoplay = true, autoplayDelay = 4000 } = Astro.props;
---

<div class="image-slider w-full relative overflow-hidden rounded-lg shadow-lg" data-autoplay={autoplay} data-delay={autoplayDelay}>
  <div class="slider-container flex transition-transform duration-500 ease-in-out">
    {images.map((image, index) => (
      <div class="slider-slide w-full flex-shrink-0">
        <img
          src={image.src}
          alt={image.alt}
          class="w-full h-[400px] md:h-[800px] object-cover"
          loading={index === 0 ? "eager" : "lazy"}
        />
      </div>
    ))}
  </div>

  <div class="slider-dots absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2">
    {images.map((_, index) => (
      <button
        class="slider-dot w-3 h-3 rounded-full bg-white/50 hover:bg-white/80 transition-colors duration-200"
        data-slide={index}
        aria-label={`Go to slide ${index + 1}`}
      ></button>
    ))}
  </div>

  <button
    class="slider-prev absolute left-4 top-1/2 transform -translate-y-1/2 bg-black/30 hover:bg-black/50 text-white p-2 rounded-full transition-colors duration-200"
    aria-label="Previous image"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
    </svg>
  </button>

  <button
    class="slider-next absolute right-4 top-1/2 transform -translate-y-1/2 bg-black/30 hover:bg-black/50 text-white p-2 rounded-full transition-colors duration-200"
    aria-label="Next image"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
    </svg>
  </button>
</div>

<script>
  class ImageSlider {
    slider: HTMLElement;
    container: HTMLElement;
    slides: NodeListOf<HTMLElement>;
    dots: NodeListOf<HTMLButtonElement>;
    prevBtn: HTMLElement;
    nextBtn: HTMLElement;
    currentSlide: number;
    totalSlides: number;
    autoplay: boolean;
    autoplayDelay: number;
    autoplayTimer: ReturnType<typeof setInterval> | null;

    constructor(element: HTMLElement) {
      this.slider = element;
      const container = element.querySelector('.slider-container');
      if (!container) throw new Error('Slider container not found');
      this.container = container as HTMLElement;
      this.slides = element.querySelectorAll('.slider-slide');
      this.dots = element.querySelectorAll('.slider-dot');
      const prevBtn = element.querySelector('.slider-prev');
      const nextBtn = element.querySelector('.slider-next');
      if (!prevBtn || !nextBtn) throw new Error('Slider navigation buttons not found');
      this.prevBtn = prevBtn as HTMLElement;
      this.nextBtn = nextBtn as HTMLElement;
      
      this.currentSlide = 0;
      this.totalSlides = this.slides.length;
      this.autoplay = element.dataset.autoplay === 'true';
      this.autoplayDelay = parseInt(element.dataset.delay ?? "4000");
      this.autoplayTimer = null;

      this.init();
    }

    init() {
      this.updateSlider();
      this.bindEvents();
      
      if (this.autoplay) {
        this.startAutoplay();
      }
    }

    bindEvents() {
      this.prevBtn.addEventListener('click', () => this.prevSlide());
      this.nextBtn.addEventListener('click', () => this.nextSlide());
      
      this.dots.forEach((dot, index) => {
        dot.addEventListener('click', () => this.goToSlide(index));
      });

      // Pause autoplay on hover
      this.slider.addEventListener('mouseenter', () => this.stopAutoplay());
      this.slider.addEventListener('mouseleave', () => {
        if (this.autoplay) this.startAutoplay();
      });
    }

    updateSlider() {
      const translateX = -this.currentSlide * 100;
      this.container.style.transform = `translateX(${translateX}%)`;
      
      // Update dots
      this.dots.forEach((dot, index) => {
        dot.classList.toggle('!bg-white', index === this.currentSlide);
      });
    }

    nextSlide() {
      this.currentSlide = (this.currentSlide + 1) % this.totalSlides;
      this.updateSlider();
    }

    prevSlide() {
      this.currentSlide = (this.currentSlide - 1 + this.totalSlides) % this.totalSlides;
      this.updateSlider();
    }

    /**
     * @param {number} index
     */
    goToSlide(index: number) {
      this.currentSlide = index;
      this.updateSlider();
    }

    startAutoplay() {
      this.stopAutoplay();
      this.autoplayTimer = setInterval(() => this.nextSlide(), this.autoplayDelay);
    }

    stopAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const sliders = document.querySelectorAll('.image-slider');
    sliders.forEach(slider => new ImageSlider(slider as HTMLElement));
  });
</script>

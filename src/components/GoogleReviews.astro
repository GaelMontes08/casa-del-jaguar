---
export interface Review {
  id: string;
  name: string;
  avatar?: string;
  rating: number;
  date: string;
  text: string;
  location?: string;
}

export interface Props {
  reviews: Review[];
  title?: string;
  showGoogleLogo?: boolean;
  autoplay?: boolean;
  autoplayDelay?: number;
}

const { 
  reviews, 
  title = "Google Reviews",
  showGoogleLogo = true,
  autoplay = true,
  autoplayDelay = 6000 
} = Astro.props;
---

<div class="google-reviews w-full">
  {title && (
    <div class="text-center mb-12">
      <h2 class="text-4xl md:text-5xl font-bold text-brand-dark font-georgia mb-4 leading-tight">
        {title}
      </h2>
      {showGoogleLogo && (
        <div class="flex items-center justify-center space-x-2 text-gray-600">
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
            <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
            <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
            <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
            <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
          </svg>
          <span class="font-gotham text-sm">Powered by Google</span>
        </div>
      )}
    </div>
  )}

  <div class="reviews-slider relative overflow-hidden cursor-grab active:cursor-grabbing group" data-autoplay={autoplay} data-delay={autoplayDelay}>
    <div class="absolute left-0 top-0 bottom-0 w-16 bg-gradient-to-r from-white to-transparent z-10 pointer-events-none"></div>
    
    <div class="absolute right-0 top-0 bottom-0 w-16 bg-gradient-to-l from-white to-transparent z-10 pointer-events-none"></div>
    
    <div class="reviews-container flex transition-transform ease-out mb-8">
      {[...reviews, ...reviews, ...reviews].map((review, index) => (
        <div class="review-slide w-full sm:w-1/2 lg:w-1/3 xl:w-1/4 flex-shrink-0 px-6 sm:px-3">
          <div class="bg-white rounded-xl shadow-lg p-5 h-full border border-gray-100 hover:shadow-xl transition-shadow duration-300 select-none mx-auto max-w-sm sm:max-w-none">
            <div class="flex items-center mb-3">
              <div class="w-10 h-10 bg-gradient-to-br from-blue-100 to-blue-200 rounded-full flex items-center justify-center mr-3">
                {review.avatar ? (
                  <img src={review.avatar} alt={review.name} class="w-10 h-10 rounded-full object-cover" draggable="false" />
                ) : (
                  <span class="text-blue-600 font-bold text-base font-gotham">
                    {review.name.charAt(0).toUpperCase()}
                  </span>
                )}
              </div>
              <div class="flex-1">
                <h4 class="font-bold text-brand-dark font-gotham text-sm">{review.name}</h4>
                {review.location && (
                  <p class="text-gray-500 text-xs font-gotham">{review.location}</p>
                )}
              </div>
            </div>

            <div class="flex items-center mb-3">
              {Array.from({ length: 5 }, (_, i) => (
                <svg
                  class={`w-4 h-4 ${i < review.rating ? 'text-yellow-400' : 'text-gray-300'}`}
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path d="M9.049 2.927c.3-.921 1.602-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                </svg>
              ))}
              <span class="ml-2 text-xs text-gray-600 font-gotham">{review.date}</span>
            </div>

            <p class="text-gray-700 text-sm leading-relaxed font-gotham">
              "{review.text}"
            </p>
          </div>
        </div>
      ))}
    </div>
  </div>
</div>

<script is:inline>
  class GoogleReviewsSlider {
    constructor(element) {
      this.slider = element;
      this.container = element.querySelector('.reviews-container');
      this.slides = element.querySelectorAll('.review-slide');
      
      this.originalReviewCount = this.slides.length / 3; // We have 3 copies
      this.slidesToShow = this.getSlidesToShow();
      this.autoplay = element.dataset.autoplay === 'true';
      this.autoplayDelay = parseInt(element.dataset.delay || '6000');
      this.autoplayTimer = null;
      
      // Infinite scroll properties
      this.currentTranslate = 0;
      this.slideWidth = 100 / this.slidesToShow;
      this.currentIndex = this.originalReviewCount; // Start at the middle copy
      
      // Continuous animation for desktop
      this.animationId = null;
      this.isAnimating = false;
      this.animationSpeed = 0.002; // Speed of continuous movement (adjust as needed)
      
      // Drag functionality
      this.isDragging = false;
      this.startPos = 0;
      this.startTranslate = 0;
      this.dragThreshold = 50; // Make drag less sensitive

      this.init();
    }

    getSlidesToShow() {
      const width = window.innerWidth;
      if (width >= 1280) return 4; // xl: 4 slides
      if (width >= 1024) return 3; // lg: 3 slides
      if (width >= 640) return 2;  // sm: 2 slides
      return 1; // mobile: 1 slide
    }

    init() {
      this.updateSlider();
      this.bindEvents();
      
      if (this.autoplay) {
        this.startAutoplay();
      }
    }

    bindEvents() {
      // Autoplay pause/resume on hover
      this.slider.addEventListener('mouseenter', () => this.stopAutoplay());
      this.slider.addEventListener('mouseleave', () => {
        if (this.autoplay) this.startAutoplay();
      });

      // Drag events - smoother implementation
      this.container.addEventListener('mousedown', this.dragStart.bind(this));
      this.container.addEventListener('touchstart', this.dragStart.bind(this), { passive: false });
      
      document.addEventListener('mouseup', this.dragEnd.bind(this));
      document.addEventListener('touchend', this.dragEnd.bind(this));
      
      document.addEventListener('mousemove', this.dragMove.bind(this));
      document.addEventListener('touchmove', this.dragMove.bind(this), { passive: false });

      // Prevent context menu on touch devices
      this.container.addEventListener('contextmenu', e => e.preventDefault());

      // Handle window resize
      window.addEventListener('resize', () => {
        const newSlidesToShow = this.getSlidesToShow();
        if (newSlidesToShow !== this.slidesToShow) {
          this.slidesToShow = newSlidesToShow;
          this.slideWidth = 100 / this.slidesToShow;
          this.updateSlider();
          
          // Restart autoplay with new timing
          if (this.autoplay) {
            this.startAutoplay();
          }
        }
      });
    }

    dragStart(e) {
      this.isDragging = true;
      this.startPos = this.getPositionX(e);
      this.startTranslate = this.currentTranslate;
      this.stopAutoplay();
      this.slider.style.cursor = 'grabbing';
      
      // Remove transition during drag for immediate response
      this.container.style.transition = 'none';
      e.preventDefault();
    }

    dragMove(e) {
      if (!this.isDragging) return;
      
      e.preventDefault();
      const currentPosition = this.getPositionX(e);
      const diff = (currentPosition - this.startPos) * 0.6; // Make drag smoother (60% sensitivity)
      
      this.currentTranslate = this.startTranslate + (diff / window.innerWidth) * 100;
      this.container.style.transform = `translateX(${this.currentTranslate}%)`;
    }

    dragEnd(e) {
      if (!this.isDragging) return;
      
      this.isDragging = false;
      this.slider.style.cursor = 'grab';
      
      // Re-enable smooth transitions
      this.container.style.transition = 'transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      
      const dragDistance = this.currentTranslate - this.startTranslate;
      
      // Only change slide if dragged enough
      if (Math.abs(dragDistance) > this.dragThreshold / window.innerWidth * 100) {
        if (dragDistance > 0) {
          this.currentIndex -= 1; // Previous slide
        } else {
          this.currentIndex += 1; // Next slide
        }
      }
      
      this.updateSlider();
      this.checkInfiniteLoop();
      
      // Resume autoplay after a delay
      if (this.autoplay) {
        setTimeout(() => this.startAutoplay(), 3000);
      }
    }

    getPositionX(e) {
      return e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
    }

    updateSlider() {
      this.currentTranslate = -this.currentIndex * this.slideWidth;
      this.container.style.transform = `translateX(${this.currentTranslate}%)`;
    }

    nextSlide() {
      // Only used for mobile discrete movement
      this.currentIndex += 1;
      this.container.style.transition = 'transform 1s linear';
      this.updateSlider();
      this.checkInfiniteLoop();
    }

    checkInfiniteLoop() {
      // Reset position for infinite loop (only used for mobile discrete movement)
      if (this.currentIndex >= this.originalReviewCount * 2 - 1) {
        setTimeout(() => {
          this.container.style.transition = 'none';
          this.currentIndex = this.originalReviewCount; // Reset to beginning of middle section
          this.updateSlider();
          
          // Re-enable transitions after reset
          setTimeout(() => {
            this.container.style.transition = 'transform 1s linear';
          }, 50);
        }, 1000); // Wait for transition to complete
      }
    }

    startAutoplay() {
      this.stopAutoplay();
      
      if (this.slidesToShow >= 3) {
        // Desktop: Continuous smooth animation
        this.startContinuousAnimation();
      } else {
        // Mobile: Discrete step animation
        this.autoplayTimer = setInterval(() => this.nextSlide(), 3000);
      }
    }

    stopAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
        this.isAnimating = false;
      }
    }

    startContinuousAnimation() {
      this.isAnimating = true;
      this.container.style.transition = 'none'; // Remove transitions for smooth continuous movement
      
      const animate = () => {
        if (!this.isAnimating) return;
        
        // Move continuously
        this.currentIndex += this.animationSpeed;
        this.updateSlider();
        
        // Check for infinite loop reset
        if (this.currentIndex >= this.originalReviewCount * 2) {
          this.currentIndex = this.originalReviewCount;
          this.updateSlider();
        }
        
        this.animationId = requestAnimationFrame(animate);
      };
      
      animate();
    }
  }

  // Initialize all review sliders
  document.addEventListener('DOMContentLoaded', () => {
    const reviewSliders = document.querySelectorAll('.reviews-slider');
    reviewSliders.forEach(slider => new GoogleReviewsSlider(slider));
  });
</script>
